## day3:

前端展示的 MVC 格式

```html
<script>
  // 数据存储层
  // 这里就是可以理解为 useState 的逻辑
  function Model() {
    this.text = "";
    this.setText = (text) => (this.text = text);
  }

  // 点击事件和数值变化的控制层
  function Controller(model) {
    const self = this;
    self.model = model;
    this.getModel = () => return self.model;
    this.onClick = (e) => {
      self.model.setText('Hi!');
      event.target.innerHTML = `<span>${self.model.text}</span>`
    }
  }

  // 视图渲染层
  function View() {
    const self = this;
    self.root = document.getElementById('malita');
    self.root.addEventListener('click', controller.onClick)
    this.render = () => {
      const text = controller.getModel().text;
      self.root.innerHTML = `<span>${text}</span>`;
    }
  }
</script>
```

当通过 html 编写 js 去实现界面渲染的时候不能直接 `return <div></div>` 会报错，而是要使用 `return React.createElement`。

为了满足这上面的需求，提高代码编写的便捷性。我们需要使用 `jsx` 的语法糖。

但是浏览器并无法识别 `jsx` 的语法，所以我们需要引入 `babel` 将 `jsx` 转化成 React 的原始语法。

**babel 的原理非常简单，通过将代码转换成抽象语法书(AST)，再转换成目标语法**

安装 `babel-standalone`，使用 `<script type="text/babel">`

## day4:

**pnpm monorepo 自动 link**

手动 `link` 并不便利，容易忘记执行 link，或者出现多版本的同名包时会出错。

引入全新的方式来帮助我们自动执行 link，`workspace`。

项目根目录下新建 `pnpm-workspace.yaml`。

```yml
packages:
  - "packages/*"
  - "examples/*"
```

声明 `packages`、`examples` 下的包都是我们的 `workspace`。在里面所有子包都可以被整个工作区中的其他包引用。就算 npm 上不存在我们的子包，只要在我们工作区内存在，就不会出现找不到子包的问题。

还有一个好处就是不管 npm 上我们的子包是什么版本，开发的时候，我们都可以直接用本地的代码。

即将项目修改成 `packages/` 多包的形式进行处理。

```bash
pnpm i

cd examples/app

pnpm start
```

总结就是，使用 `pnpm` 的形式，在 `pnpm-workspace.yaml` 下设置 `workspace`。能够自动 link 并且实时使用本地的代码。
